#include "nds-example.h"

#include <iostream>
#include <mutex>
#include <unistd.h>

#include <nds3/nds.h>

#define NDS_EPOCH 1514764800 /* 00:00 of 1/1/2018 in UTC format. */

using namespace std;
using namespace std::placeholders;
static std::map<std::string, Device*> m_DevicesMap;

static std::mutex m_lockDevicesMap;

Device::Device(nds::Factory &factory, const std::string &DeviceName, const nds::namedParameters_t & parameters ):
m_name(DeviceName)

{
    {
        std::lock_guard<std::mutex> lock(m_lockDevicesMap);
        if(m_DevicesMap.find(DeviceName) != m_DevicesMap.end())
        {
            throw std::logic_error("Device with the same name already allocated. This should not happen");
        }
        m_DevicesMap[DeviceName] = this;
    }
    nds::Port rootNode(DeviceName);

    m_VarIn_vDBL=nds::PVVariableIn<std::vector<double>>("VarIn_vDBL");
    m_VarIn_vDBL.setMaxElements(2); //initializing the PV with 2 elements
    m_VarIn_vDBL.setValue(std::vector<double>(2,0));
    rootNode.addChild(m_VarIn_vDBL);
    m_VarOut_vDBL=nds::PVVariableOut<std::vector<double>>("VarOut_vDBL");
    rootNode.addChild(m_VarOut_vDBL);
    //adding a state machine node
    m_Device_stateMachine=rootNode.addChild(nds::StateMachine(true,
            std::bind(&Device::switchOn_Device, this),
            std::bind(&Device::switchOff_Device,this),
            std::bind(&Device::start_Device,this),
            std::bind(&Device::stop_Device,this),
            std::bind(&Device::recover_Device,this),
            std::bind(&Device::allow_Device_Change,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3)
    ));

    nds::autoEnable_t autoEnable = nds::autoEnable_t::none;
    nds::namedParameters_t::const_iterator findParam =  parameters.find("AUTOENABLE");
    if (findParam != parameters.end()) {
        if(findParam->second== "OFF"){
            autoEnable = nds::autoEnable_t::off;
        }else if(findParam->second== "ON"){
            autoEnable = nds::autoEnable_t::on;
        }else if(findParam->second== "RUNNING"){
            autoEnable = nds::autoEnable_t::running;
        }
    }
    /**
     * Add a DataAcquisition node: it acquires data generated by the WaveformGeneration node and supplies an input PV on which we can push the
     * acquired data, it also adds a state machine that allows to start and stop the acquisition.
     */
    findParam =  parameters.find("INIT");
    if (findParam != parameters.end() && findParam->second=="YES") {
        //Set compulsory methods
        nds::DataAcquisitionArgs_t handlerDAQ = nds::DataAcquisitionArgs_t (
                std::bind(&Device::switchOn_DataAcquisition, this),
                std::bind(&Device::switchOff_DataAcquisition, this),
                std::bind(&Device::start_DataAcquisition, this),
                std::bind(&Device::stop_DataAcquisition, this),
                std::bind(&Device::recover_DataAcquisition, this),
                std::bind(&Device::allow_DataAcquisition_Change, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                std::bind(&Device::PV_DataAcquisition_Gain_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Offset_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Bandwidth_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Resolution_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Impedance_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Coupling_Writer,this,   std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_SignalRefType_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_Ground_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_DMAEnable_Writer,this,std::placeholders:: _1,std::placeholders::_2),
                std::bind(&Device::PV_DataAcquisition_SamplingRate_Writer,this,std::placeholders::_1,std::placeholders::_2),
                autoEnable
        );
        //Set optional methods
        handlerDAQ.PV_Gain_Initializer = std::bind(&Device::PV_DataAcquisition_Gain_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Offset_Initializer = std::bind(&Device::PV_DataAcquisition_Offset_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Bandwidth_Initializer = std::bind(&Device::PV_DataAcquisition_Bandwidth_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Resolution_Initializer = std::bind(&Device::PV_DataAcquisition_Resolution_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Impedance_Initializer = std::bind(&Device::PV_DataAcquisition_Impedance_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Coupling_Initializer = std::bind(&Device::PV_DataAcquisition_Coupling_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_SignalRefType_Initializer = std::bind(&Device::PV_DataAcquisition_SignalRefType_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Ground_Initializer = std::bind(&Device::PV_DataAcquisition_Ground_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_DMAEnable_Initializer = std::bind(&Device::PV_DataAcquisition_DMAEnable_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_SamplingRate_Initializer = std::bind(&Device::PV_DataAcquisition_SamplingRate_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        //Set init values
        handlerDAQ.m_Decimation_Init = 1;
        handlerDAQ.m_DecimationType_Init = 2;
        m_DataAcquisition = rootNode.addChild(nds::DataAcquisition<std::vector<double>>(
                "DataAcquisitionNode",
                128,
                handlerDAQ));
    } else {
        m_DataAcquisition=rootNode.addChild(nds::DataAcquisition<std::vector<double>>
                ("DataAcquisitionNode",
                        128,
                        bind(&Device::switchOn_DataAcquisition, this),
                        std::bind(&Device::switchOff_DataAcquisition,this),
                        std::bind(&Device::start_DataAcquisition,this),
                        std::bind(&Device::stop_DataAcquisition,this),
                        std::bind(&Device::recover_DataAcquisition,this),
                        std::bind(&Device::allow_DataAcquisition_Change,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3),
                        std::bind(&Device::PV_DataAcquisition_Gain_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Offset_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Bandwidth_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Resolution_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Impedance_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Coupling_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_SignalRefType_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_Ground_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_DMAEnable_Writer,this,std::placeholders:: _1,std::placeholders::_2),
                        std::bind(&Device::PV_DataAcquisition_SamplingRate_Writer,this,std::placeholders::_1,std::placeholders::_2),
                        autoEnable
                ));
    }
    rootNode.initialize(this,factory);
    timespec timest;
    timest.tv_nsec=5; timest.tv_sec=50;
    int nDChannels=4;

    m_DataAcquisition.setDMANumChannels(timest,nDChannels );
}
Device::~Device()
{

}

Device* Device::getInstance(const std::string& DeviceName)
{
    std::lock_guard<std::mutex> lock(m_lockDevicesMap);

    std::map<std::string, Device*>::const_iterator findDevice = m_DevicesMap.find(DeviceName);
    if(findDevice == m_DevicesMap.end())
    {
        return 0;
    }
    return findDevice->second;
}

/*
 * Allocation function
 *********************/
void* Device::allocateDevice(nds::Factory& factory, const std::string& DeviceName, const nds::namedParameters_t& parameters)
{
    return new Device(factory, DeviceName, parameters);
}

/*
 * Deallocation function
 ***********************/
void Device::deallocateDevice(void* DeviceName)
{
    // It is necessary to erase the device from the map. To free the name for further use
    m_DevicesMap.erase(((Device*)DeviceName)->m_name);
    delete (Device*)DeviceName;
}

void Device::switchOn_Device() {
}

void Device::switchOff_Device() {
}

void Device::start_Device() {
}

void Device::stop_Device() {
}

void Device::recover_Device() {
}

bool Device::allow_Device_Change(const nds::state_t , const nds::state_t , const nds::state_t) {
    return true;
}

void Device::switchOn_DataAcquisition() {
}

void Device::switchOff_DataAcquisition() {
}

void Device::start_DataAcquisition() {
    m_bStop_DataAcquisition=false;
    m_DataAcquisition_Thread =
      m_DataAcquisition.runInThread("DAQ",
                    std::bind(&Device::DataAcquisition_thread_body,this));
}

void Device::stop_DataAcquisition() {
    m_bStop_DataAcquisition=true;
    m_DataAcquisition_Thread.join();
}

void Device::recover_DataAcquisition() {
    throw nds::StateMachineRollBack("Cannot recover");
}

bool Device::allow_DataAcquisition_Change(const nds::state_t , const nds::state_t , const nds::state_t ) {
    return true;
}

void Device::DataAcquisition_thread_body() {

    /**
     * Let's allocate a vector that will contain the data that we
     * will push to the control system or to the data acquisition
     * node*/
    std::vector<double> outputData(m_DataAcquisition.getMaxElements(),0);
    size_t nElm = m_DataAcquisition.getMaxElements();
    double counter(0);

    //Counter for number of pushed data blocks
    std::int32_t NumberOfPushedDataBlocks(0);

    // Get Gain
    double Gain = m_DataAcquisition.getGain();
    // Get Bandwidth
    double Bandwidth = m_DataAcquisition.getBandwidth();
    // Get Resolution
    double Resolution = m_DataAcquisition.getResolution();
    // Get Coupling
    double Coupling = m_DataAcquisition.getCoupling();
    // Get SignalRefType
    double SignalRefTYpe = m_DataAcquisition.getSignalRefType();
    // Get Ground
    double Ground = m_DataAcquisition.getGround();
    // Get offset
    double Offset = m_DataAcquisition.getOffset();
    // Get impedance
    std::int32_t Impedance = m_DataAcquisition.getImpedance();
    // Get SamplingRate
    double SamplingRate = m_DataAcquisition.getSamplingRate();

    std::cout<<"\tGain = "<< Gain<<std::endl;
    std::cout<<"\tBandwidth = "<<Bandwidth<<std::endl;
    std::cout<<"\tResolution = "<<Resolution<<std::endl;
    std::cout<<"\tCoupling = "<<Coupling<<std::endl;
    std::cout<<"\tSignalRefType = "<<SignalRefTYpe<<std::endl;
    std::cout<<"\tGround = "<<Ground<<std::endl;
    std::cout<<"\tOffset = "<<Offset<<std::endl;
    std::cout<<"\tImpedance = "<<Impedance<<std::endl;
    std::cout<<"\tSamplingRate = "<<SamplingRate<<std::endl;
    // Run until the state machine stops us
    while(!m_bStop_DataAcquisition){

        outputData.clear();
        outputData.resize(nElm,counter);
        ++counter;

        // Push the vector to the control system
        m_DataAcquisition.push(m_DataAcquisition.getTimestamp(), outputData);
        ++NumberOfPushedDataBlocks;
        // Rest for a while
        ::usleep(100000);
    }
    m_DataAcquisition.setNumberOfPushedDataBlocks(m_DataAcquisition.getTimestamp(),NumberOfPushedDataBlocks);
}

void Device::PV_DataAcquisition_Gain_Writer(const timespec& timestamp,
    const double& value) {
    double HW_value;
    HW_value=value;
    m_DataAcquisition.setGain(timestamp,HW_value);
}

void Device::PV_DataAcquisition_Offset_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the Offset to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Offset programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setOffset(timestamp,HW_value);
}

void Device::PV_DataAcquisition_Bandwidth_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the Bandwidth to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Bandwidth programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setBandwidth(timestamp,HW_value);
}

void Device::PV_DataAcquisition_Resolution_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the Resolution to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Resolution programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setResolution(timestamp,HW_value);
}

void Device::PV_DataAcquisition_Impedance_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the Impedance to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Impedance programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setImpedance(timestamp,HW_value);
}

void Device::PV_DataAcquisition_Coupling_Writer(const timespec& timestamp,
        const std::int32_t& value) {
    std::int32_t HW_value;
    //Value has the Coupling to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Coupling programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setCoupling(timestamp,HW_value);
}

void Device::PV_DataAcquisition_SignalRefType_Writer(const timespec& timestamp,
        const std::int32_t& value) {
    std::int32_t HW_value;
    //Value has the SignalRefType to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real SignalRefType programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setSignalRefType(timestamp,HW_value);
}
void Device::PV_DataAcquisition_Ground_Writer(const timespec& timestamp,
        const std::int32_t& value) {
    std::int32_t HW_value;
    //Value has the Ground to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Ground programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setGround(timestamp,HW_value);
}


void Device::PV_DataAcquisition_DMAEnable_Writer(const timespec& timestamp,
        const std::int32_t& value) {
    std::int32_t HW_value;
    //Value has the DMAEnable value to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real DMAEnable value programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setDMAEnable(timestamp,HW_value);
}

void Device::PV_DataAcquisition_SamplingRate_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the SamplingRate to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real SamplingRate programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setSamplingRate(timestamp,HW_value);
}


void Device::PV_DataAcquisition_Gain_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 10};
    *value = 2.5; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_Offset_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 20};
    *value = 3.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_Bandwidth_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 30};
    *value = 10.0; //Note that this value has no sense and it is fixed only for testing purposes.

}

void Device::PV_DataAcquisition_Resolution_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 40};
    *value = 15.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_Impedance_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 50};
    *value = 2.2; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_Coupling_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 60};
    *value = 1; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_SignalRefType_Initializer(
        timespec* timestamp, int32_t* value) {
    *timestamp = {NDS_EPOCH, 70};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_Ground_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 80};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_DMAEnable_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 90};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void Device::PV_DataAcquisition_SamplingRate_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 100};
    *value = 10.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

NDS_DEFINE_DRIVER(Device, Device)
