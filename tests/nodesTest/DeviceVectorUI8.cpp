#include <mutex>
#ifdef _WIN32
static const double M_PI = 3.14159265358979323846;
#else
#include <unistd.h>
#endif
#include <functional>

#include <nds3/nds.h>

#include "DeviceVectorUI8.h"

#define NDS_EPOCH 1514764800 /* 00:00 of 1/1/2018 in UTC format. */


static std::map<std::string, DeviceVectorUI8*> m_devicesMap;
static std::mutex m_lockDevicesMap;

DeviceVectorUI8::DeviceVectorUI8(nds::Factory &factory, const std::string &deviceName, const nds::namedParameters_t & parameters):
    m_name(deviceName), timestamp_device{0,0},readtimeStamp{0,0}
{
    //TODO:Study this.
    {
        std::lock_guard<std::mutex> lock(m_lockDevicesMap);
        if(m_devicesMap.find(deviceName) != m_devicesMap.end())
        {
            throw std::logic_error("Device with the same name already allocated. This should not happen");
        }
        m_devicesMap[deviceName] = this;
    }

    /**
     * Here we declare the root node.
     * It is a good practice to name it with the device name.
     *
     * Also, for simplicity we declare it as a "Port": this means that
     * the root node will be responsible for the communication with
     * the underlying control system.
     *
     * It is possible to have the root node as a simple Node and promote one or
     * more of its children to "Port": each port will interface with a different
     * control system thread.
     */
    nds::Port rootNode(deviceName);

    nds::namedParameters_t::const_iterator findParam =  parameters.find("INIT");

    /**
     * Add a DataAcquisition node: it acquires data generated by the WaveformGeneration node and supplies an input PV on which we can push the
     * acquired data, it also adds a state machine that allows to start and stop the acquisition.
     */
    if (findParam != parameters.end() && findParam->second=="YES") {
         //Set compulsory methods
        nds::DataAcquisitionArgs_t handlerDAQ = nds::DataAcquisitionArgs_t (
                std::bind(&DeviceVectorUI8::switchOn_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::switchOff_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::start_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::stop_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::recover_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::allow_DataAcquisition_Change, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Gain_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Offset_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Bandwidth_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Resolution_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Impedance_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Coupling_Writer,this,   std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_SignalRefType_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Ground_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_DMAEnable_Writer,this,std::placeholders:: _1,std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_SamplingRate_Writer,this,std::placeholders::_1,std::placeholders::_2)
            );
        //Set optional methods
        handlerDAQ.PV_Gain_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Gain_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Offset_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Offset_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Bandwidth_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Bandwidth_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Resolution_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Resolution_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Impedance_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Impedance_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Coupling_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Coupling_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_SignalRefType_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_SignalRefType_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_Ground_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_Ground_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_DMAEnable_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_DMAEnable_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerDAQ.PV_SamplingRate_Initializer = std::bind(&DeviceVectorUI8::PV_DataAcquisition_SamplingRate_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        //Set init values
        handlerDAQ.m_Decimation_Init = 1;
        handlerDAQ.m_DecimationType_Init = 2;
        m_DataAcquisition = rootNode.addChild(nds::DataAcquisition<std::vector<std::uint8_t>>(
                        "DataAcquisitionNode",
                        128,
                        handlerDAQ));
    } else {
        m_DataAcquisition = rootNode.addChild(nds::DataAcquisition<std::vector<std::uint8_t>>(
                "DataAcquisitionNode",
                128,
                std::bind(&DeviceVectorUI8::switchOn_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::switchOff_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::start_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::stop_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::recover_DataAcquisition, this),
                std::bind(&DeviceVectorUI8::allow_DataAcquisition_Change, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Gain_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Offset_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Bandwidth_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Resolution_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Impedance_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Coupling_Writer,this,   std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_SignalRefType_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_Ground_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_DMAEnable_Writer,this,std::placeholders:: _1,std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_DataAcquisition_SamplingRate_Writer,this,std::placeholders::_1,std::placeholders::_2)
        ));
    }

    /**
     * Add a WaveformGeneration node: it acquires data generated by the WaveformGeneration node and supplies an input PV on which we can push the
     * acquired data, it also adds a state machine that allows to start and stop the acquisition.
     */
    if (findParam != parameters.end() && findParam->second=="YES") {
         //Set compulsory methods
        nds::WaveformGenerationArgs_t<std::vector<std::uint8_t>> handlerWFG = nds::WaveformGenerationArgs_t<std::vector<std::uint8_t>>(
                std::bind(&DeviceVectorUI8::switchOn_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::switchOff_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::start_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::stop_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::recover_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::allow_WaveformGeneration_Change, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Frequency_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_RefFrequency_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Amp_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Phase_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_UpdateRate_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_DutyCycle_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Gain_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Offset_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Bandwidth_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Resolution_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Impedance_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Coupling_Writer,this,   std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalRef_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalType_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Ground_Writer,this, std::placeholders::_1, std::placeholders::_2));
        //Set optional methods
        handlerWFG.PV_Frequency_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Frequency_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_RefFrequency_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_RefFrequency_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Amp_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Amp_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Phase_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Phase_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_UpdateRate_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_UpdateRate_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_DutyCycle_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_DutyCycle_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Gain_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Gain_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Offset_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Offset_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Bandwidth_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Bandwidth_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Resolution_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Resolution_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Impedance_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Impedance_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Coupling_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Coupling_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_SignalRef_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalRef_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_SignalType_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalType_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        handlerWFG.PV_Ground_Initializer = std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Ground_Initializer, this, std::placeholders::_1, std::placeholders::_2);
        //Set init values
        handlerWFG.m_Decimation_Init = 1;
        handlerWFG.m_DataAWG_Init = std::vector<std::uint8_t> (128, 2); //128 integers with value 2
        //Add the WFG node
        m_WaveformGeneration = rootNode.addChild(nds::WaveformGeneration<std::vector<std::uint8_t>>("WFGNode",128,handlerWFG));
    } else {
        m_WaveformGeneration = rootNode.addChild(nds::WaveformGeneration<std::vector<std::uint8_t>>(
                "WFGNode",
                128,
                std::bind(&DeviceVectorUI8::switchOn_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::switchOff_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::start_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::stop_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::recover_WaveformGeneration, this),
                std::bind(&DeviceVectorUI8::allow_WaveformGeneration_Change, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Frequency_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_RefFrequency_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Amp_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Phase_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_UpdateRate_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_DutyCycle_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Gain_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Offset_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Bandwidth_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Resolution_Writer,this, std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Impedance_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Coupling_Writer,this,   std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalRef_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_SignalType_Writer,this,  std::placeholders::_1, std::placeholders::_2),
                std::bind(&DeviceVectorUI8::PV_WaveformGeneration_Ground_Writer,this, std::placeholders::_1, std::placeholders::_2)
        ));
    }

    timespec timestamp={0,0};
    m_setCurrentTime = rootNode.addChild(nds::PVVariableOut<std::int32_t>("setCurrentTime"));
    m_setCurrentTime.write(timestamp, (std::int32_t)NDS_EPOCH);

    //  We have declared all the nodes with several types of PVs in our Device: now we register them
    //  with the control system that called this constructor.
    ////////////////////////////////////////////////////////////////////////////////
    rootNode.initialize(this, factory);
    rootNode.setTimestampDelegate(std::bind(&DeviceVectorUI8::getCurrentTime,this));
}



DeviceVectorUI8::~DeviceVectorUI8()
{
    std::lock_guard<std::mutex> lock(m_lockDevicesMap);
    m_devicesMap.erase(m_name);

}

DeviceVectorUI8* DeviceVectorUI8::getInstance(const std::string& deviceName)
{
    std::lock_guard<std::mutex> lock(m_lockDevicesMap);

    std::map<std::string, DeviceVectorUI8*>::const_iterator findDevice = m_devicesMap.find(deviceName);
    if(findDevice == m_devicesMap.end())
    {
        return 0;
    }
    return findDevice->second;
}


timespec DeviceVectorUI8::getCurrentTime()
{
    timespec time;
    time.tv_sec = m_setCurrentTime.getValue();
    time.tv_nsec = time.tv_sec + 10;
    return time;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// DATA ACQUISITION NODE*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* DataAcquisition State Machine
*/

// Called when the DataAcquisition node has to be switched on.
void DeviceVectorUI8::switchOn_DataAcquisition(){

}

// Called when the DataAcquisition node has to be switched off.
void DeviceVectorUI8::switchOff_DataAcquisition(){

}

// Called when the DataAcquisition node has to start acquiring. We start the data acquisition thread.
void DeviceVectorUI8::start_DataAcquisition(){

    m_bStop_DataAcquisition = false; //< We will set to true to stop the acquisition thread
    /**
     *   Start the acquisition thread.
     *   We don't need to check if the thread was already started because the state
     *   machine guarantees that the start handler is called only while the state
     *   is ON.
     */
    m_DataAcquisition_Thread = m_DataAcquisition.runInThread(std::bind(&DeviceVectorUI8::DataAcquisition_thread_body, this));
}

// Stop the DataAcquisition node thread
void DeviceVectorUI8::stop_DataAcquisition(){
    m_bStop_DataAcquisition = true;
    m_DataAcquisition_Thread.join();
}

// A failure during a state transition will cause the state machine to switch to the failure state. For now we don't plan for this and every time the
//  state machine wants to recover we throw StateMachineRollBack to force the state machine to stay on the failure state.
void DeviceVectorUI8::recover_DataAcquisition(){
    throw nds::StateMachineRollBack("Cannot recover"); //TODO: Study this
}

// We always allow the state machine to switch state. Before calling this function the state machine has already verified that the requested state transition is legal.
bool DeviceVectorUI8::allow_DataAcquisition_Change(const nds::state_t, const nds::state_t, const nds::state_t){
    return true;
}

/*
* DataAcquisition setters
*/
void DeviceVectorUI8::PV_DataAcquisition_Gain_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Gain to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Gain programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setGain(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Offset_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Offset to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Offset programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setOffset(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Bandwidth_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Bandwidth to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Bandwidth programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setBandwidth(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Resolution_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Resolution to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Resolution programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setResolution(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Impedance_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Impedance to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Impedance programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setImpedance(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Coupling_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the Coupling to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Coupling programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setCoupling(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_SignalRefType_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the SignalRefType to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real SignalRefType programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setSignalRefType(timestamp,HW_value);
}
void DeviceVectorUI8::PV_DataAcquisition_Ground_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the Ground to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Ground programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setGround(timestamp,HW_value);
}

void DeviceVectorUI8::PV_DataAcquisition_DMAEnable_Writer(const timespec& timestamp, const std::int32_t& value) {
    std::int32_t HW_value;
    //Value has the DMAEnable value to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real DMAEnable value programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setDMAEnable(timestamp,HW_value);
}

void DeviceVectorUI8::PV_DataAcquisition_SamplingRate_Writer(const timespec& timestamp,
        const double& value) {
    double HW_value;
    //Value has the SamplingRate to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real SamplingRate programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_DataAcquisition.setSamplingRate(timestamp,HW_value);
}

void DeviceVectorUI8::PV_DataAcquisition_Gain_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 10};
    *value = 2.5; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_Offset_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 20};
    *value = 3.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_Bandwidth_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 30};
    *value = 10.0; //Note that this value has no sense and it is fixed only for testing purposes.

}

void DeviceVectorUI8::PV_DataAcquisition_Resolution_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 40};
    *value = 15.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_Impedance_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 50};
    *value = 2.2; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_Coupling_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 60};
    *value = 1; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_SignalRefType_Initializer(
        timespec* timestamp, int32_t* value) {
    *timestamp = {NDS_EPOCH, 70};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_Ground_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 80};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_DMAEnable_Initializer(timespec* timestamp,
        int32_t* value) {
    *timestamp = {NDS_EPOCH, 90};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_DataAcquisition_SamplingRate_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 100};
    *value = 10.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Frequency_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 110};
    *value = 2.5e6; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_RefFrequency_Initializer(
        timespec* timestamp, double* value) {
    *timestamp = {NDS_EPOCH, 120};
    *value = 1.0e3; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Amp_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 130};
    *value = 3.3; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Phase_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 140};
    *value = 60.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_UpdateRate_Initializer(
        timespec* timestamp, double* value) {
    *timestamp = {NDS_EPOCH, 150};
    *value = 4.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_DutyCycle_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 160};
    *value = 75.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Gain_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 170};
    *value = 5.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Offset_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 180};
    *value = 1.1; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Bandwidth_Initializer(timespec* timestamp,
        double* value) {
    *timestamp = {NDS_EPOCH, 190};
    *value = 20.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Resolution_Initializer(
        timespec* timestamp, double* value) {
    *timestamp = {NDS_EPOCH, 200};
    *value = 2.0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Impedance_Initializer(timespec* timestamp,
        std::int32_t* value) {
    *timestamp = {NDS_EPOCH, 210};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Coupling_Initializer(timespec* timestamp,
        std::int32_t* value) {
    *timestamp = {NDS_EPOCH, 220};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_SignalRef_Initializer(timespec* timestamp,
        std::int32_t* value) {
    *timestamp = {NDS_EPOCH, 230};
    *value = 1; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_SignalType_Initializer(
        timespec* timestamp, std::int32_t* value) {
    *timestamp = {NDS_EPOCH, 240};
    *value = 1; //Note that this value has no sense and it is fixed only for testing purposes.
}

void DeviceVectorUI8::PV_WaveformGeneration_Ground_Initializer(timespec* timestamp,
        std::int32_t* value) {
    *timestamp = {NDS_EPOCH, 250};
    *value = 0; //Note that this value has no sense and it is fixed only for testing purposes.
}

/*
* Body of function to acquire data
*/
void DeviceVectorUI8::DataAcquisition_thread_body(){
    // Let's allocate a vector that will contain the data that we will push to the control system or to the data acquisition node
        std::vector<std::uint8_t> outputData(m_DataAcquisition.getMaxElements(),0);

        std::uint8_t counter(0);

        //Counter for number of pushed data blocks
        std::int32_t NumberOfPushedDataBlocks(0);

        // Get Gain
        double Gain = m_DataAcquisition.getGain();
        // Get Bandwidth
        double Bandwidth = m_DataAcquisition.getBandwidth();
        // Get Resolution
        double Resolution = m_DataAcquisition.getResolution();
        // Get Coupling
        double Coupling = m_DataAcquisition.getCoupling();
        // Get SignalRefType
        double SignalRefType = m_DataAcquisition.getSignalRefType();
        // Get Ground
        double Ground = m_DataAcquisition.getGround();
        // Get offset
        double Offset = m_DataAcquisition.getOffset();
        // Get impedance
        std::int32_t Impedance = m_DataAcquisition.getImpedance();
        // Get DMABufferSize
        std::int32_t DMABufferSize = m_DataAcquisition.getDMABufferSize();
        // Get DMANumChannels
        std::int32_t DMANumChannels = m_DataAcquisition.getDMANumChannels();
        // Get DMAFrametype
        std::int32_t DMAFrameType = m_DataAcquisition.getDMAFrameType();
        // Get DMASampleSize
        std::int32_t DMASampleSize = m_DataAcquisition.getDMASampleSize();
        // Get DMAEnable
        std::int32_t DMAEnable = m_DataAcquisition.getDMAEnable();
        // Get SamplingRate
        double SamplingRate = m_DataAcquisition.getSamplingRate();

        std::cout<<"\tGain = "<< Gain<<std::endl;
        std::cout<<"\tBandwidth = "<<Bandwidth<<std::endl;
        std::cout<<"\tResolution = "<<Resolution<<std::endl;
        std::cout<<"\tCoupling = "<<Coupling<<std::endl;
        std::cout<<"\tSignalRefType = "<<SignalRefType<<std::endl;
        std::cout<<"\tGround = "<<Ground<<std::endl;
        std::cout<<"\tOffset = "<<Offset<<std::endl;
        std::cout<<"\tImpedance = "<<Impedance<<std::endl;
        std::cout<<"\tDMABufferSize = "<<DMABufferSize<<std::endl;
        std::cout<<"\tDMANumChannels = "<<DMANumChannels<<std::endl;
        std::cout<<"\tDMAFrameType = "<<DMAFrameType<<std::endl;
        std::cout<<"\tDMASampleSize = "<<DMASampleSize<<std::endl;
        std::cout<<"\tDMAEnable = "<<DMAEnable<<std::endl;
        std::cout<<"\tSamplingRate = "<<SamplingRate<<std::endl;

        // Run until the state machine stops us
        while(!m_bStop_DataAcquisition){

            size_t scanVector(0);
            for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                outputData[scanVector] = counter;
            }
            counter++;

        // Push the vector to the control system
        m_DataAcquisition.push(m_DataAcquisition.getTimestamp(), outputData);
        ++NumberOfPushedDataBlocks;

        // Rest for a while
        ::usleep(100000);
        }
        m_DataAcquisition.setNumberOfPushedDataBlocks(m_DataAcquisition.getTimestamp(),NumberOfPushedDataBlocks);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
// DATA GENERATION NODE*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* WaveformGeneration State Machine
*/

void DeviceVectorUI8::switchOn_WaveformGeneration(){

}

void DeviceVectorUI8::switchOff_WaveformGeneration(){

}

void DeviceVectorUI8::start_WaveformGeneration(){
    m_bStop_WaveformGeneration = false; //< We will set to true to stop the acquisition thread
    /**
     *   Start the acquisition thread.
     *   We don't need to check if the thread was already started because the state
     *   machine guarantees that the start handler is called only while the state
     *   is ON.
     */
    m_WaveformGeneration_Thread =
      m_WaveformGeneration.runInThread("WFG",
                       std::bind(&DeviceVectorUI8::WaveformGeneration_thread_body, this));
}

void DeviceVectorUI8::stop_WaveformGeneration(){
    m_bStop_WaveformGeneration = true;
    m_WaveformGeneration_Thread.join();
}

void DeviceVectorUI8::recover_WaveformGeneration(){
    throw nds::StateMachineRollBack("Cannot recover"); //TODO: Study this
}

bool DeviceVectorUI8::allow_WaveformGeneration_Change(const nds::state_t, const nds::state_t, const nds::state_t){
    return true;
}

/*
* WaveformGeneration setters
*/
void DeviceVectorUI8::PV_WaveformGeneration_Frequency_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the frequency to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real frequency programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setFrequency(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_RefFrequency_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the RefFrequency to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real RefFrequency programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setRefFrequency(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Amp_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //value has the amplitude to be programmed on the hardware
    //call to function programming the hardware. This function should return the real amplitude programmed. This value has to be set to the readback attribute.
    //in the meantime without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setAmplitude(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Phase_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Phase to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Phase programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setPhase(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_UpdateRate_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the UpdateRate to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real UpdateRate programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setUpdateRate(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_DutyCycle_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the DutyCycle to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real DutyCycle programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setDutyCycle(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Gain_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Gain to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Gain programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setGain(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Offset_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Offset to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Offset programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setOffset(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Bandwidth_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Bandwidth to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Bandwidth programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setBandwidth(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Resolution_Writer(const timespec& timestamp, const double& value){
    double HW_value;
    //Value has the Resolution to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Resolution programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setResolution(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Impedance_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the Impedance to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Impedance programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setImpedance(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Coupling_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the Coupling to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real Coupling programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setCoupling(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_SignalRef_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //Value has the SignalRef to be programmed on the hardware.
    //Call to function programming the hardware. This function should return the real SignalRef programmed. This value has to be set to the readback attribute.
    //In the meantime, without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setSignalRef(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_SignalType_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //value has the SignalType to be programmed on the hardware
    //call to function programming the hardware. This function should return the real SignalType programmed. This value has to be set to the readback attribute.
    //in the meantime without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setSignalType(timestamp,HW_value);
}
void DeviceVectorUI8::PV_WaveformGeneration_Ground_Writer(const timespec& timestamp, const std::int32_t& value){
    std::int32_t HW_value;
    //value has the Ground to be programmed on the hardware
    //call to function programming the hardware. This function should return the real Ground programmed. This value has to be set to the readback attribute.
    //in the meantime without real hardware value and  HW_value are equal.
    HW_value=value;
    m_WaveformGeneration.setGround(timestamp,HW_value);
}

/*
* Body of function to generate data. In this example we are going to generate a sine wave.
*/
void DeviceVectorUI8::WaveformGeneration_thread_body(){

    // Let's allocate a vector that will contain the data that we will push to the control system or to the data acquisition node
    std::vector<std::uint8_t> outputData(m_WaveformGeneration.getMaxElements(),0);

    //Counter for number of pushed data blocks
    std::int32_t NumberOfPushedDataBlocks(0);

    // A counter for the angle in the sin() operation
    std::int64_t angle(0);

    size_t last_sample(0);

    // Get RefFrequency
    double RefFrequency = m_WaveformGeneration.getRefFrequency();
    // Get DutyCycle
    double DutyCycle = m_WaveformGeneration.getDutyCycle();
    // Get Gain
    double Gain = m_WaveformGeneration.getGain();
    // Get Bandwidth
    double Bandwidth = m_WaveformGeneration.getBandwidth();
    // Get Resolution
    double Resolution = m_WaveformGeneration.getResolution();
    // Get Coupling
    double Coupling = m_WaveformGeneration.getCoupling();
    // Get SignalRef
    double SignalRef = m_WaveformGeneration.getSignalRef();
    // Get Ground
    double Ground = m_WaveformGeneration.getGround();
    // Get impedance
    std::int32_t impedance = m_WaveformGeneration.getImpedance();

    std::cout<<"Signal generator configured with:"<<std::endl;
    std::cout<<"\tRefFrequency = "<<RefFrequency<<std::endl;
    std::cout<<"\tDutyCycle = "<<DutyCycle<<std::endl;
    std::cout<<"\tGain = "<<Gain<<std::endl;
    std::cout<<"\tBandwidth = "<<Bandwidth<<std::endl;
    std::cout<<"\tResolution = "<<Resolution<<std::endl;
    std::cout<<"\tCoupling = "<<Coupling<<std::endl;
    std::cout<<"\tSignalRef = "<<SignalRef<<std::endl;
    std::cout<<"\tGround = "<<Ground<<std::endl;
    std::cout<<"\tImpedance = "<<impedance<<std::endl;

    // Run until the state machine stops us
    while(!m_bStop_WaveformGeneration){

        size_t scanVector(0);

        // Get signalType
        size_t signalType = m_WaveformGeneration.getSignalType();
        // Get amplitude
        double amplitude = m_WaveformGeneration.getAmplitude();
        // Get frequency
        double frequency = m_WaveformGeneration.getFrequency();
        // Get updateRate
        double updateRate = m_WaveformGeneration.getUpdateRate();
        // Get offset
        double offset = m_WaveformGeneration.getOffset();
        // Get phase
        double phase = m_WaveformGeneration.getPhase();

        switch(signalType){

            case 0:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                last_sample+=scanVector;
                break;
            case 1:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
            case 2:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
            case 3:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = (double)amplitude * sin((2*M_PI*(scanVector+last_sample)*frequency)/updateRate + phase) + offset;
                }
                break;
            case 4:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = ((angle & 0xff) < 128) ? amplitude : - amplitude;
                }
                break;
            case 5:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
            case 6:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
            case 7:
                for(scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
            default:
                for( scanVector=0; scanVector != outputData.size(); ++scanVector){
                    outputData[scanVector] = amplitude;
                }
                break;
        }

        //Save last sample generated.
        last_sample+=scanVector;

    // Push the vector to the control system
    m_WaveformGeneration.push(m_WaveformGeneration.getTimestamp(), outputData);
    ++NumberOfPushedDataBlocks;
    //TODO: Send values to data acquisition node.

    // Rest for a while
    ::usleep(100000);
    }
    m_WaveformGeneration.setNumberOfPushedDataBlocks(m_WaveformGeneration.getTimestamp(),NumberOfPushedDataBlocks);
}

// NDS_DEFINE_DRIVER(DeviceVectorUI8, DeviceVectorUI8)

 /**
  * Allocation function
  *********************/
 void* DeviceVectorUI8::allocateDevice(nds::Factory& factory, const std::string& deviceName, const nds::namedParameters_t& parameters)
 {
     return new DeviceVectorUI8(factory, deviceName, parameters);
 }

 /**
  * Deallocation function
  ***********************/
 void DeviceVectorUI8::deallocateDevice(void* deviceName)
 {
     delete (DeviceVectorUI8*)deviceName;
 }
