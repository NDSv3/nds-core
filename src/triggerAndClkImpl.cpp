/*
 * Nominal Device Support v.3 (NDS3)
 *
 * For more information about the license please refer to the license.txt
 * file included in the distribution.
 *
 *  By GMV & UPM
 */


#include "nds3/definitions.h"
#include "nds3/impl/routingImpl.h"
#include "nds3/impl/triggerAndClkImpl.h"
#include "nds3/impl/stateMachineImpl.h"
#include "nds3/impl/pvVariableInImpl.h"
#include "nds3/impl/pvVariableOutImpl.h"
#include "nds3/impl/pvDelegateOutImpl.h"
#include "nds3/impl/pvDelegateInImpl.h"



namespace nds
{

template<typename T>
TriggerAndClkImpl<T>::TriggerAndClkImpl(
         const std::string& name,
            stateChange_t switchOnFunction,
            stateChange_t switchOffFunction,
            stateChange_t startFunction,
            stateChange_t stopFunction,
            stateChange_t recoverFunction,
            allowChange_t allowStateChangeFunction,
            writerInt32_t PV_SetSW_Writer,
            writerInt32_t PV_LoadTrigConf_Writer,
            writerInt32_t PV_ResetTrigConf_Writer,
            writerInt32_t PV_PLLSyncSET_Writer,
            writerInt32_t PV_EnableDisablePLL_Writer,
            const nds::Routing<std::string>& _routingNode,
            autoEnable_t autoEnable):
            NodeImpl(name, nodeType_t::dataSourceChannel),
            m_OnStartDelegate(startFunction),
            m_StartTimestampFunction(std::bind(&BaseImpl::getTimestamp, this)),
            routingNode(_routingNode)
{
  TriggerAndClkArgs_t handlerTrig = TriggerAndClkArgs_t(switchOnFunction,
                                                        switchOffFunction,
                                                        startFunction,
                                                        stopFunction,
                                                        recoverFunction,
                                                        allowStateChangeFunction,
                                                        PV_SetSW_Writer,
                                                        PV_LoadTrigConf_Writer,
                                                        PV_ResetTrigConf_Writer,
                                                        PV_PLLSyncSET_Writer,
                                                        PV_EnableDisablePLL_Writer,
                                                        _routingNode,
                                                        autoEnable);
  constructorBody(handlerTrig);
}

template<typename T>
TriggerAndClkImpl<T>::TriggerAndClkImpl(
                 const std::string& name,  const TriggerAndClkArgs_t& handlerTrig):
                 NodeImpl(name, nodeType_t::dataSourceChannel),
                 m_OnStartDelegate(handlerTrig.handlerSTM.startFunction),
                 m_StartTimestampFunction(std::bind(&BaseImpl::getTimestamp, this)),
                 routingNode(handlerTrig.routingNode)
{
  constructorBody(handlerTrig);
}

template<typename T>
inline void TriggerAndClkImpl<T>::constructorBody(const TriggerAndClkArgs_t& handlerTrig)
{
    timespec tst = getTimestamp();
    m_HWBlock_PV.reset(new PVVariableOutImpl<std::int32_t>("HWBlock"));
    m_HWBlock_PV->setDescription("Number identifying a HW-functional block to program the trigger functionality (For instance AI, DI, AO, DO)");
    m_HWBlock_PV->write(tst, handlerTrig.m_HWBlock_Init);
    addChild(m_HWBlock_PV);

    m_HWBlock_PVRBV.reset(new PVVariableInImpl<std::int32_t>("HWBlock_RBV"));
    m_HWBlock_PVRBV->setDescription("Number identifying a HW-functional block to program the trigger functionality (For instance AI, DI, AO, DO) Readback Value.");
    m_HWBlock_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_HWBlock_PVRBV);

    if (handlerTrig.PV_SetSW_Initializer){
        m_SetSW_PV.reset(new PVDelegateOutImpl<std::int32_t>("SetSW",
                                                             handlerTrig.PV_SetSW_Writer,
                                                             handlerTrig.PV_SetSW_Initializer));
    } else {
        m_SetSW_PV.reset(new PVDelegateOutImpl<std::int32_t>("SetSW",handlerTrig.PV_SetSW_Writer));
    }
    m_SetSW_PV->setDescription("Immediate trigger generated by SOFTWARE.");
    m_SetSW_PV->setScanType(scanType_t::passive, 0);
    addChild(m_SetSW_PV);

    m_DAQStartTimeDelay_PV.reset(new PVVariableOutImpl<std::int32_t>("DAQStartTimeDelay"));
    m_DAQStartTimeDelay_PV->setDescription("Time to delay the DAQ after trigger.");
    m_DAQStartTimeDelay_PV->write(tst, handlerTrig.m_DAQStartTimeDelay_Init);
    addChild(m_DAQStartTimeDelay_PV);

    m_DAQStartTimeDelay_RBVPV.reset(new PVVariableInImpl<std::int32_t>("DAQStartTimeDelay_RBV"));
    m_DAQStartTimeDelay_RBVPV->setDescription("Time to delay the DAQ after trigger ReadBack Value");
    m_DAQStartTimeDelay_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_DAQStartTimeDelay_RBVPV);

    m_TriggPeriod_PV.reset(new PVVariableOutImpl<std::int32_t>("TrigPeriod"));
    m_TriggPeriod_PV->setDescription("Trigger Period");
    m_TriggPeriod_PV->write(tst, handlerTrig.m_TriggPeriod_Init);
    addChild(m_TriggPeriod_PV);

    m_TriggPeriod_RBVPV.reset(new PVVariableInImpl<std::int32_t>("TrigPeriod_RBV"));
    m_TriggPeriod_RBVPV->setDescription("Trigger Period ReadBack");
    m_TriggPeriod_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_TriggPeriod_RBVPV);

    m_Level_PV.reset(new PVVariableOutImpl<std::int32_t>("Level"));
    m_Level_PV->setDescription("Select Level configuration for the trigger (HIGH or LOW)");
    m_Level_PV->setScanType(scanType_t::interrupt, 0);
    m_Level_PV->write(tst, handlerTrig.m_Level_Init);
    addChild(m_Level_PV);

    m_Level_RBVPV.reset(new PVVariableInImpl<std::int32_t>("Level_RBV"));
    m_Level_RBVPV->setDescription("Select Level configuration for the trigger (HIGH or LOW). ReadBack Value");
    m_Level_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_Level_RBVPV);

    m_Edge_PV.reset(new PVVariableOutImpl<std::int32_t>("Edge"));
    m_Edge_PV->setDescription("Detection edge for the trigger (RISING or FALLING)");
    m_Edge_PV->setScanType(scanType_t::interrupt, 0);
    m_Edge_PV->write(tst, handlerTrig.m_Edge_Init);
    addChild(m_Edge_PV);

    m_Edge_RBVPV.reset(new PVVariableInImpl<std::int32_t>("Edge_RBV"));
    m_Edge_RBVPV->setDescription("Detection edge for the trigger (RISING or FALLING). ReadBack Value");
    m_Edge_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_Edge_RBVPV);

    m_Change_PV.reset(new PVVariableOutImpl<std::int32_t>("Change"));
    m_Change_PV->setDescription("Select LEVEL or EDGE for the trigger");
    m_Change_PV->setScanType(scanType_t::interrupt, 0);
    m_Change_PV->write(tst, handlerTrig.m_Change_Init);
    addChild(m_Change_PV);

    m_Change_RBVPV.reset(new PVVariableInImpl<std::int32_t>("Change_RBV"));
    m_Change_RBVPV->setDescription("Select LEVEL or EDGE for the trigger ReadBack Value");
    m_Change_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_Change_RBVPV);

    m_Mode_PV.reset(new PVVariableOutImpl<std::int32_t>("Mode"));
    m_Mode_PV->setDescription("The action (operation) executed when the trigger is received.");
    m_Mode_PV->setScanType(scanType_t::interrupt, 0);
    m_Mode_PV->write(tst, handlerTrig.m_Mode_Init);
    addChild(m_Mode_PV);

    m_ClkDivider_PV.reset(new PVVariableOutImpl<std::int32_t>("ClkDivider"));
    m_ClkDivider_PV->setDescription("The divider value for the trigger clock.");
    m_ClkDivider_PV->setScanType(scanType_t::interrupt, 0);
    m_ClkDivider_PV->write(tst, handlerTrig.m_ClkDivider_Init);
    addChild(m_ClkDivider_PV);

    m_Mode_RBVPV.reset(new PVVariableInImpl<std::int32_t>("Mode_RBV"));
    m_Mode_RBVPV->setDescription("The action (operation) executed when the trigger is received. ReadBack Value");
    m_Mode_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_Mode_RBVPV);

    m_ClkDivider_RBVPV.reset(new PVVariableInImpl<std::int32_t>("ClkDivider_RBV"));
    m_ClkDivider_RBVPV->setDescription("The divider value for the trigger clock. ReadBack Value");
    m_ClkDivider_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_ClkDivider_RBVPV);

    m_preTrigSamples_PV.reset(new PVVariableOutImpl<std::int32_t>("PreTrigSamples"));
    m_preTrigSamples_PV->setDescription("Number of samples to be acquired BEFORE the trigger condition is met(only if REF-RETRIGERABLE is configured)");
    m_preTrigSamples_PV->setScanType(scanType_t::interrupt, 0);
    m_preTrigSamples_PV->write(tst, handlerTrig.m_PreTrigSamples_Init);
    addChild(m_preTrigSamples_PV);

    m_preTrigSamples_RBVPV.reset(new PVVariableInImpl<std::int32_t>("PreTrigSamples_RBV"));
    m_preTrigSamples_RBVPV->setDescription("Number of samples to be acquired BEFORE the trigger condition is met(only if REF-RETRIGERABLE is configured). ReadBack Value");
    m_preTrigSamples_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_preTrigSamples_RBVPV);

    m_postTrigSamples_PV.reset(new PVVariableOutImpl<std::int32_t>("PostTrigSamples"));
    m_postTrigSamples_PV->setDescription("Number of samples to be acquired AFTER the trigger condition is met.");
    m_postTrigSamples_PV->setScanType(scanType_t::interrupt, 0);
    m_postTrigSamples_PV->write(tst, handlerTrig.m_PostTrigSamples_Init);
    addChild(m_postTrigSamples_PV);

    m_postTrigSamples_RBVPV.reset(new PVVariableInImpl<std::int32_t>("PostTrigSamples_RBV"));
    m_postTrigSamples_RBVPV->setDescription("Number of samples to be acquired AFTER the trigger condition is met. ReadBack Value");
    m_postTrigSamples_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_postTrigSamples_RBVPV);

    if (handlerTrig.PV_LoadTrigConf_Initializer) {
        m_LoadTrigConf_PV.reset(new PVDelegateOutImpl<std::int32_t>("LoadTrigConf",
                                                                    handlerTrig.PV_LoadTrigConf_Writer,
                                                                    handlerTrig.PV_LoadTrigConf_Initializer));
    } else {
        m_LoadTrigConf_PV.reset(new PVDelegateOutImpl<std::int32_t>("LoadTrigConf",
                                                                    handlerTrig.PV_LoadTrigConf_Writer));
    }
    m_LoadTrigConf_PV->setDescription("Write all the trigger configurations to the hardware.");
    addChild(m_LoadTrigConf_PV);

    if (handlerTrig.PV_ResetTrigConf_Initializer) {
        m_ResetTrigConf_PV.reset(new PVDelegateOutImpl<std::int32_t>("ResetTrigConf",
                                                                     handlerTrig.PV_ResetTrigConf_Writer,
                                                                     handlerTrig.PV_ResetTrigConf_Initializer));
    } else {
        m_ResetTrigConf_PV.reset(new PVDelegateOutImpl<std::int32_t>("ResetTrigConf",handlerTrig.PV_ResetTrigConf_Writer));
    }
    m_ResetTrigConf_PV->setDescription("Reset the hardware configuration.");
    addChild(m_ResetTrigConf_PV);

    m_trigLoadStatus_PV.reset(new PVVariableInImpl<std::string>("TrigLoadStatus"));
    m_trigLoadStatus_PV->setDescription("LoadTrigConf status message.");
    m_trigLoadStatus_PV->setScanType(scanType_t::interrupt, 0);
    addChild(m_trigLoadStatus_PV);

    m_trigLoadCode_PV.reset(new PVVariableInImpl<std::int32_t>("TrigLoadCode"));
    m_trigLoadCode_PV->setDescription("LoadTrigConf error code.");
    m_trigLoadCode_PV->setScanType(scanType_t::interrupt, 0);
    addChild(m_trigLoadCode_PV);

    m_syncMode_PV.reset(new PVVariableOutImpl<std::int32_t>("SyncMode"));
    m_syncMode_PV->setDescription("If PLL is enabled, the device can be enabled for master or slave. Should have a value.");
    m_syncMode_PV->setScanType(scanType_t::interrupt, 0);
    m_syncMode_PV->write(tst, handlerTrig.m_SyncMode_Init);
    addChild(m_syncMode_PV);

    m_syncMode_PVRBV.reset(new PVVariableInImpl<std::int32_t>("SyncMode_RBV"));
    m_syncMode_PVRBV->setDescription("If PLL is enabled, the device can be enabled for master or slave (Should have a value). ReadBack Value.");
    m_syncMode_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_syncMode_PVRBV);

    if (handlerTrig.PV_PLLSyncSet_Initializer) {
        m_PLLSyncSet_PV.reset(new PVDelegateOutImpl<std::int32_t>("PLLSyncSET",
                                                                  handlerTrig.PV_PLLSyncSet_Writer,
                                                                  handlerTrig.PV_PLLSyncSet_Initializer));
    } else {
        m_PLLSyncSet_PV.reset(new PVDelegateOutImpl<std::int32_t>("PLLSyncSET",
                                                                  handlerTrig.PV_PLLSyncSet_Writer));
    }
    m_PLLSyncSet_PV->setDescription("Write PLL configuration to hardware");
    addChild(m_PLLSyncSet_PV);

    m_PLLRefFreq_PV.reset(new PVVariableOutImpl<std::int32_t>("PLLRefFreq"));
    m_PLLRefFreq_PV->setDescription("PLL Reference Frequency");
    m_PLLRefFreq_PV->setScanType(scanType_t::interrupt, 0);
    m_PLLRefFreq_PV->write(tst, handlerTrig.m_PLLRefFreq_Init);
    addChild(m_PLLRefFreq_PV);

    m_PLLRefFreq_PVRBV.reset(new PVVariableInImpl<std::int32_t>("PLLRefFreq_RBV"));
    m_PLLRefFreq_PVRBV->setDescription("PLL Reference Frequency. ReadBack Value.");
    m_PLLRefFreq_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLRefFreq_PVRBV);

    m_PLLRefDiv_PV.reset(new PVVariableOutImpl<std::int32_t>("PLLRefDiv"));
    m_PLLRefDiv_PV->setDescription("PLL Reference Divisor");
    m_PLLRefDiv_PV->setScanType(scanType_t::interrupt, 0);
    m_PLLRefDiv_PV->write(tst, handlerTrig.m_PLLRefDiv_Init);
    addChild(m_PLLRefDiv_PV);

    m_PLLRefDiv_PVRBV.reset(new PVVariableInImpl<std::int32_t>("PLLRefDiv_RBV"));
    m_PLLRefDiv_PVRBV->setDescription("PLL Reference Divisor. ReadBack Value");
    m_PLLRefDiv_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLRefDiv_PVRBV);

    m_PLLRefMult_PV.reset(new PVVariableOutImpl<std::int32_t>("PLLRefMult"));
    m_PLLRefMult_PV->setDescription("PLL Reference Multiplier");
    m_PLLRefMult_PV->setScanType(scanType_t::interrupt, 0);
    m_PLLRefMult_PV->write(tst, handlerTrig.m_PLLRefMult_Init);
    addChild(m_PLLRefMult_PV);

    m_PLLRefMult_PVRBV.reset(new PVVariableInImpl<std::int32_t>("PLLRefMult_RBV"));
    m_PLLRefMult_PVRBV->setDescription("PLL Reference Multiplier. ReadBack Value");
    m_PLLRefMult_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLRefMult_PVRBV);

    m_PLLRefDivALL_PV.reset(new PVVariableOutImpl<std::int32_t>("PLLRefDivALL"));
    m_PLLRefDivALL_PV->setDescription("PLL Reference Divisor");
    m_PLLRefDivALL_PV->setScanType(scanType_t::interrupt, 0);
    m_PLLRefDivALL_PV->write(tst, handlerTrig.m_PLLRefDivAll_Init);
    addChild(m_PLLRefDivALL_PV);

    m_PLLRefDivALL_PVRBV.reset(new PVVariableInImpl<std::int32_t>("PLLRefDivALL_RBV"));
    m_PLLRefDivALL_PVRBV->setDescription("PLL Reference Divisor. ReadBack Value");
    m_PLLRefDivALL_PVRBV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLRefDivALL_PVRBV);

    m_PLLLoadStatus_PV.reset(new PVVariableInImpl<std::string>("PLLLoadStatus"));
    m_PLLLoadStatus_PV->setDescription("PLL Load status message.");
    m_PLLLoadStatus_PV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLLoadStatus_PV);

    m_PLLLoadCode_PV.reset(new PVVariableInImpl<std::int32_t>("PLLLoadCode"));
    m_PLLLoadCode_PV->setDescription("PLL Load error code.");
    m_PLLLoadCode_PV->setScanType(scanType_t::interrupt, 0);
    addChild(m_PLLLoadCode_PV);

    if (handlerTrig.PV_EnableDisablePLL_Initializer) {
        m_EnableDisablePLL_PV.reset(new PVDelegateOutImpl<std::int32_t>("EnableDisablePLL",
                                                                        handlerTrig.PV_EnableDisablePLL_Writer,
                                                                        handlerTrig.PV_EnableDisablePLL_Initializer));
    } else {
            m_EnableDisablePLL_PV.reset(new PVDelegateOutImpl<std::int32_t>("EnableDisablePLL",
                                                                            handlerTrig.PV_EnableDisablePLL_Writer));
    }
    m_EnableDisablePLL_PV->setDescription("Enable or disable PLL.");
    addChild(m_EnableDisablePLL_PV);

    m_EnableDisablePLL_RBVPV.reset(new PVVariableInImpl<std::int32_t>("EnableDisablePLL_RBV"));
    m_EnableDisablePLL_RBVPV->setDescription("Enable or disable PLL Readback Value.");
    m_EnableDisablePLL_RBVPV->setScanType(scanType_t::interrupt, 0);
    addChild(m_EnableDisablePLL_RBVPV);

    // Add state machine
    m_StateMachine.reset(new StateMachineImpl(false,
            handlerTrig.handlerSTM.switchOnFunction,
            handlerTrig.handlerSTM.switchOffFunction,
            std::bind(&TriggerAndClkImpl::onStart, this),
            handlerTrig.handlerSTM.stopFunction,
            handlerTrig.handlerSTM.recoverFunction,
            handlerTrig.handlerSTM.allowStateChangeFunction,
            handlerTrig.handlerSTM.autoEnable));
    addChild(m_StateMachine);

}


template<typename T>
timespec TriggerAndClkImpl<T>::getStartTimestamp() const
{
    return m_StartTime;
}

template<typename T>
void TriggerAndClkImpl<T>::setStartTimestampDelegate(getTimestampPlugin_t timestampDelegate)
{
    m_StartTimestampFunction = timestampDelegate;
}

template<typename T>
void TriggerAndClkImpl<T>::onStart()
{
    m_StartTime = m_StartTimestampFunction();
    m_OnStartDelegate();
}

template<typename T>
nds::state_t TriggerAndClkImpl<T>::getState()
{
    return m_StateMachine->getLocalState();
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getHWBlock(){

    std::int32_t HWBlock;
    timespec timestamp;
    m_HWBlock_PV->read(&timestamp, &HWBlock);
    return HWBlock;

}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getDAQStartTimeDelay(){

    std::int32_t DAQStartTimeDelay;
    timespec timestamp;
    m_DAQStartTimeDelay_PV->read(&timestamp, &DAQStartTimeDelay);
    return DAQStartTimeDelay;

}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getTriggPeriod(){

    std::int32_t TriggPeriod;
    timespec timestamp;
    m_TriggPeriod_PV->read(&timestamp, &TriggPeriod);
    return TriggPeriod;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getLevel(){

    std::int32_t Level;
    timespec timestamp;
    m_Level_PV->read(&timestamp, &Level);
    return Level;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getEdge(){

    std::int32_t Edge;
    timespec timestamp;
    m_Edge_PV->read(&timestamp, &Edge);
    return Edge;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getChange(){

    std::int32_t Change;
    timespec timestamp;
    m_Change_PV->read(&timestamp, &Change);
    return Change;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getMode(){

    std::int32_t Mode;
    timespec timestamp;
    m_Mode_PV->read(&timestamp, &Mode);
    return Mode;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getClkDivider(){

    std::int32_t ClkDivider;
    timespec timestamp;
    m_ClkDivider_PV->read(&timestamp, &ClkDivider);
    return ClkDivider;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPreTrigSamples(){

    std::int32_t preTrigSamples;
    timespec timestamp;
    m_preTrigSamples_PV->read(&timestamp, &preTrigSamples);
    return preTrigSamples;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPostTrigSamples(){

    std::int32_t postTrigSamples;
    timespec timestamp;
    m_postTrigSamples_PV->read(&timestamp, &postTrigSamples);
    return postTrigSamples;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getSyncMode(){

    std::int32_t syncMode;
    timespec timestamp;
    m_syncMode_PV->read(&timestamp, &syncMode);
    return syncMode;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPLLRefFreq(){

    std::int32_t PLLRefFreq;
    timespec timestamp;
    m_PLLRefFreq_PV->read(&timestamp, &PLLRefFreq);
    return PLLRefFreq;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPLLRefDiv(){

    std::int32_t PLLRefDiv;
    timespec timestamp;
    m_PLLRefDiv_PV->read(&timestamp, &PLLRefDiv);
    return PLLRefDiv;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPLLRefMult(){

    std::int32_t PLLRefMult;
    timespec timestamp;
    m_PLLRefMult_PV->read(&timestamp, &PLLRefMult);
    return PLLRefMult;
}

template<typename T>
std::int32_t TriggerAndClkImpl<T>::getPLLRefDivALL(){

    std::int32_t PLLRefDivALL;
    timespec timestamp;
    m_PLLRefDivALL_PV->read(&timestamp, &PLLRefDivALL);
    return PLLRefDivALL;
}

template<typename T>
void TriggerAndClkImpl<T>::setHWBlockRBV(const timespec& timestamp, const std::int32_t& value){

    m_HWBlock_PVRBV->setValue(timestamp, value);
    m_HWBlock_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setDAQStartTimeDelayRBV(const timespec& timestamp, const std::int32_t& value){

    m_DAQStartTimeDelay_RBVPV->setValue(timestamp, value);
    m_DAQStartTimeDelay_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setTriggPeriodRBV(const timespec& timestamp, const std::int32_t& value){

    m_TriggPeriod_RBVPV->setValue(timestamp, value);
    m_TriggPeriod_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setLevelRBV(const timespec& timestamp, const std::int32_t& value){

    m_Level_RBVPV->setValue(timestamp, value);
    m_Level_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setEdgeRBV(const timespec& timestamp, const std::int32_t& value){

    m_Edge_RBVPV->setValue(timestamp, value);
    m_Edge_RBVPV->push(timestamp, value);
}


template<typename T>
void TriggerAndClkImpl<T>::setChangeRBV(const timespec& timestamp, const std::int32_t& value){

    m_Change_RBVPV->setValue(timestamp, value);
    m_Change_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setModeRBV(const timespec& timestamp, const std::int32_t& value){

    m_Mode_RBVPV->setValue(timestamp, value);
    m_Mode_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setClkDividerRBV(const timespec& timestamp, const std::int32_t& value){

    m_ClkDivider_RBVPV->setValue(timestamp, value);
    m_ClkDivider_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPreTrigSamplesRBV(const timespec& timestamp, const std::int32_t& value){

    m_preTrigSamples_RBVPV->setValue(timestamp, value);
    m_preTrigSamples_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPostTrigSamplesRBV(const timespec& timestamp, const std::int32_t& value){

    m_postTrigSamples_RBVPV->setValue(timestamp, value);
    m_postTrigSamples_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setTrigLoadStatus(const timespec& timestamp, const std::string& value){

    m_trigLoadStatus_PV->setValue(timestamp, value);
    m_trigLoadStatus_PV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setTrigLoadCode(const timespec& timestamp, const std::int32_t& value){

    m_trigLoadCode_PV->setValue(timestamp, value);
    m_trigLoadCode_PV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setSyncModeRBV(const timespec& timestamp, const std::int32_t& value){

    m_syncMode_PVRBV->setValue(timestamp, value);
    m_syncMode_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLRefFreqRBV(const timespec& timestamp, const std::int32_t& value){
    m_PLLRefFreq_PVRBV->setValue(timestamp, value);
    m_PLLRefFreq_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLRefDivRBV(const timespec& timestamp, const std::int32_t& value){
    m_PLLRefDiv_PVRBV->setValue(timestamp, value);
    m_PLLRefDiv_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLRefMultRBV(const timespec& timestamp, const std::int32_t& value){
    m_PLLRefMult_PVRBV->setValue(timestamp, value);
    m_PLLRefMult_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLRefDivALLRBV(const timespec& timestamp, const std::int32_t& value){
    m_PLLRefDivALL_PVRBV->setValue(timestamp, value);
    m_PLLRefDivALL_PVRBV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLLoadStatus(const timespec& timestamp, const std::string& value){

    m_PLLLoadStatus_PV->setValue(timestamp, value);
    m_PLLLoadStatus_PV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setPLLLoadCode(const timespec& timestamp, const std::int32_t& value){

    m_PLLLoadCode_PV->setValue(timestamp, value);
    m_PLLLoadCode_PV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setEnableDisablePLLRBV(const timespec& timestamp, const std::int32_t& value){

    m_EnableDisablePLL_RBVPV->setValue(timestamp, value);
    m_EnableDisablePLL_RBVPV->push(timestamp, value);
}

template<typename T>
void TriggerAndClkImpl<T>::setState(const nds::state_t& newState)
{
    m_StateMachine->setState(newState);
}

template class TriggerAndClkImpl<std::vector<timespec>>;


}
